//#C:\pro\SourceMod\MySMcompile.exe "$(FULL_CURRENT_PATH)"
#define DEBUG 1
#define PLUGIN_NAME  "KnifeDuel"
#define PLUGIN_VERSION "0.1"
//Забыл что делать в функции DelayFight
#include "k64t"
// ConVar
new Handle:cvar_KnifeDuel_BeginTimer        = INVALID_HANDLE;
new Float:BeginTimer = 5.0;
new Handle:cvar_MinPlayers  = INVALID_HANDLE;
new MinPlayers =4;
new Handle:cvar_sv_alltalk	= INVALID_HANDLE;
//
new bool:bombplanted	=false;
new bool:isFighting		=false;
new ctid, tid;
new ct_team_cnt,t_team_cnt;	
new team;
new Handle:g_hMyCookie;
new g_WeaponParent;
new String:ctname[32];
new String:tname[32];
public Plugin:myinfo =
{
    name = PLUGIN_NAME,
    author = "k64t@ya.ru",
    description = "",
    version = PLUGIN_VERSION,
    url = ""
};
//***********************************************
public OnPluginStart(){
//***********************************************
#if defined DEBUG
DebugPrint("OnPluginStart");
#endif
cvar_sv_alltalk = FindConVar("sv_alltalk");
    if ( cvar_sv_alltalk == INVALID_HANDLE )
    {
        LogError("FATAL: Cannot find sv_alltalk cvar.");
        SetFailState("[%s] %s",PLUGIN_NAME,"Cannot find sv_alltalk cvar.");
    }
LoadTranslations("KnifeDuel.phrases");
cvar_KnifeDuel_BeginTimer	= CreateConVar("KnifeDuel_BeginTimer","5",
	"The number of seconds after which start duel, where each team will have only one player",true,0);
cvar_MinPlayers				= CreateConVar("MinPlayers","4",
	"Minimum number of players before knife fights will trigger",true,4);

HookEvent("player_death",	EventPlayerDeath);
HookEvent("bomb_planted",	EventBombPlanted,	EventHookMode_PostNoCopy);
HookEvent("round_start",	EventRoundStart,	EventHookMode_PostNoCopy);
HookEvent("bomb_beginplant",EventBombBeginPlant);
HookEvent("bomb_abortplant",EventBombAbortPlant);
HookEvent("hostage_follows",EventHostageFollows);
HookEvent("hostage_stops_following",EventHostageStopsFollowing);
RegConsoleCmd("k_KnifeDuel", cmd_KnifeDuel, "");
g_hMyCookie = RegClientCookie(PLUGIN_NAME, PLUGIN_NAME, CookieAccess_Protected);
}
//***********************************************
public Action:cmd_KnifeDuel(client, args){
//***********************************************
}

//***********************************************
public OnMapStart(){
//***********************************************
#if defined DEBUG
DebugPrint("OnMapStart");
#endif
AutoExecConfig(true, "KnifeDuel");
BeginTimer= GetConVarFloat(cvar_KnifeDuel_BeginTimer);
MinPlayers= GetConVarInt(cvar_MinPlayers);
}
//***********************************************
public EventBombBeginPlant			(Handle:event, const String:name[],bool:dontBroadcast){bombplanted = true;}
public EventBombAbortPlant			(Handle:event, const String:name[],bool:dontBroadcast){bombplanted = false;}
public EventHostageFollows			(Handle:event, const String:name[],bool:dontBroadcast){bombplanted = true;}
public EventHostageStopsFollowing	(Handle:event, const String:name[],bool:dontBroadcast){bombplanted = false;}
public EventBombPlanted				(Handle:event, const String:name[],bool:dontBroadcast){bombplanted = true;}
//***********************************************
public EventRoundStart(Handle:event, const String:name[],bool:dontBroadcast){
//***********************************************
#if defined DEBUG
DebugPrint("EventRoundStart");
#endif
bombplanted=false;
isFighting=false;
}
//***********************************************
public EventPlayerDeath(Handle:event,const String:name[],bool:dontBroadcast){
//***********************************************
#if defined DEBUG
DebugPrint("EventPlayerDeath");
#endif

if (bombplanted) return;
if (isFighting)
	{
	new loser = GetClientOfUserId(GetEventInt(event, "userid"));
	if (loser == ctid || loser == tid)
		{
		new winner = GetClientOfUserId(GetEventInt(event, "attacker"));
		if ( (winner != loser) && (winner != 0) )
			{
			new String:winnername[MAX_NAME_LENGTH];		
			GetClientName(winner, winnername, sizeof(winnername));
			//PrintToChatAll("[%s] %s has won",PLUGIN_NAME,winnername);
			//Set bonus for winner			
			}
		}
		CancelFight();
	}
else
	{	
	for (new i = 1; i <= MaxClients; i++)
        {      
		#if defined DEBUG
		DebugPrint(i);
		#endif		
		if (IsClientInGame(i) && IsPlayerAlive(i))
			{
			team = GetClientTeam(i);
			if (team == CS_TEAM_CT) { ctid = i; ct_team_cnt++;if (ct_team_cnt>1)return; }
			else if (team == CS_TEAM_T) { tid = i; t_team_cnt++;if (t_team_cnt>1)return; }
			}
        }
        if (ct_team_cnt == 1 && t_team_cnt == 1 && !bombplanted)
        {        
		#if defined DEBUG
		DebugPrint("1vs1");
		#endif
		CreateTimer(BeginTimer,VerifyConditions);
        }
	}
}

//***********************************************
public Action:CancelFight(){
//***********************************************
}

//***********************************************
public Action:VerifyConditions(Handle:timer){
//***********************************************
#if defined DEBUG
DebugPrint("VerifyConditions");
#endif
if (ctid == 0 || tid == 0)return;
if (GetClientCount() < MinPlayers)return;

if ( IsClientInGame(ctid) && IsPlayerAlive(ctid) && IsClientInGame(tid) &&  IsPlayerAlive(tid) )
    {
        if ( IsFakeClient(ctid) &&  IsFakeClient(tid) )
        {
        //    //if ( !g_isBotFightAllowed )
        //    //{
            return;
        //    //}
        }

        
        GetClientName(ctid, ctname, sizeof(ctname));
        GetClientName(tid, tname, sizeof(tname));
        PrintHintTextToAll("%t", "1v1 situation");
        
		//if ( g_forcefight )
        //{
            CreateTimer(0.5, DelayFight);
        //}
        //else
        //{
        //    SendKnifeMenus(ctid,tid);
        //}
    }
}
//***********************************************
public Action:DelayFight(Handle:timer){StartFight();}
//***********************************************
public Action:StartFight(){ 
//***********************************************
#if defined DEBUG
DebugPrint("StartFight");
#endif   
// check if one player left server
if (ctid == 0 || tid == 0)return;  

// check if there are only two players
ct_team_cnt = 0, t_team_cnt = 0;
for (new i = 1; i <= MaxClients; i++)
{
	new team;
	if (IsClientInGame(i) && IsPlayerAlive(i))
	{
		team = GetClientTeam(i);
		if (team == CS_TEAM_CT) { ct_team_cnt++;}
		else if (team == CS_TEAM_T) { t_team_cnt++;}
	}
}
    
// check if there are only two players and round has 
// not ended or bomb is not planted
if (ct_team_cnt != 1 || t_team_cnt != 1 || bombplanted)return;
    

// start fight
isFighting = true;
#if defined DEBUG
DebugPrint("Fight is started.");
#endif 
if (!IsPlayerAlive(ctid) || !IsPlayerAlive(tid) || (GetClientCount() < MinPlayers))
    {
	CancelFight();
	return;
    }
#if defined DEBUG
DebugPrint("Removing all weapons on the map.");
#endif     

    
// Remove all weapons from the map
RemoveAllWeapons();
    
/*    // play fight song
    if (songsfound > 0)
    {
        new randomsong = 0;
        if (songsfound > 1)
        {
            randomsong = GetRandomInt(0, songsfound - 1);
        }
        strcopy(song, sizeof(song), fightsong[randomsong]);
        
        new clients[MaxClients];
        new total = 0;
        for (new i=1; i<=MaxClients; i++)
        {
            if (IsClientInGame(i) && g_soundPrefs[i])
            {
                clients[total++] = i;
            }
        }

        if (total)
        {
            Trace("Starting fight song.");
            EmitSound(clients, total, song, 
                _, SNDCHAN_AUTO, SNDLEVEL_NORMAL, SND_NOFLAGS, SNDVOL_NORMAL, SNDPITCH_NORMAL);
        }
    }
*/	
    
//    Trace("Starting beacons.");
//    // start beacons
//    CreateTimer(2.0, StartBeacon, ctid, TIMER_REPEAT);
//    CreateTimer(1.0, StartBeaconT, tid);

    // remove weapons from players
    // PrintHintTextToAll("%t", "Removing weapons");
    WeaponHandler(ctid, 3);
    WeaponHandler(tid, 2);
    
    // switch alltalk
    //if (g_alltalk) 
    //{
    //    g_alltalkenabled = GetConVarBool(sv_alltalk);
    //    if ( !g_alltalkenabled )
    //    {
SetConVarInt(cvar_sv_alltalk, 1);
    //    }
    //    g_alltalkenabled = !g_alltalkenabled;
    //}
    
    // switch blocking
	/*
    if ( g_block )
    {
        if ( sm_noblock == INVALID_HANDLE )
        {
            sm_noblock = FindConVar("sm_noblock");
        }
        if ( sm_noblock != INVALID_HANDLE )
        {
            g_blockenabled = !GetConVarBool(sm_noblock);
            if ( !g_blockenabled )
            {
                SetConVarInt(sm_noblock, 0);
            }
            g_blockenabled = !g_blockenabled;
        }
    }
	*/
    
    // teleport players
	//->
	/*
    if (g_useteleport)
    {
        SetEntData(ctid, g_iHealth, 400);
        SetEntData(tid, g_iHealth, 400);
        new Float:ctvec[3];
        new Float:tvec[3];
        new Float:distance[1];
        GetClientAbsOrigin(ctid,Float:ctvec);
        GetClientAbsOrigin(tid,Float:tvec);
        distance[0] = GetVectorDistance(ctvec, tvec, true);
        if (distance[0] >= 600000.0)
        {
            teleloc = ctvec;
            CreateTimer(0.1, SlapTimer, _, TIMER_REPEAT);
            CreateTimer(0.5, TeleportTimer);
        }
        else if (g_locatorbeam)
        {
            CreateTimer(0.1, DrawBeamsTimer, _, TIMER_REPEAT);
        }
    }
    else if (g_locatorbeam)
    {
        CreateTimer(0.1, DrawBeamsTimer, _, TIMER_REPEAT);
    }
    */
    // display prepare to fight
    //->CreateTimer(1.0, Countdown, _, TIMER_REPEAT);
	
}

//***********************************************
WeaponHandler(client, teamid){
//***********************************************
/*->
    if ( isFighting )
    {
        new count = 0;
        for (new i = 0; i <= 128; i += 4)
        {
            new weaponentity = -1;
            new String:weaponname[32];
            weaponentity = GetEntDataEnt2(client, (g_iMyWeapons + i));
            if ( IsValidEdict(weaponentity) )
            {
                GetEdictClassname(weaponentity, weaponname, sizeof(weaponname));
                if ( (weaponentity != -1) && !StrEqual(weaponname, "worldspawn", false) )
                {
                    if ( teamid == 3 || teamid == 2 )
                    {
                        RemovePlayerItem(client, weaponentity);
                        RemoveEdict(weaponentity);
                        if ( teamid == 3 )
                        {
                            ctitems[count++] = weaponname;
                        }
                        else if ( teamid == 2 )
                        {
                            titems[count++] = weaponname;
                        }
                    }
                }
            }
        }
    }
    else
    {
        // we have a winner, so give all its weapons we removed before
        RemoveWeapon(client, "knife");
        for ( new i = 0; i <= 7 ; i++ )
        {
            if ( IsClientInGame(client) )
            {   
                if (teamid == 3)
                {
                    if ( !StrEqual(ctitems[i], "", false) )
                    {
                        GivePlayerItem(client, ctitems[i]);
                    }
                }
                else if (teamid == 2)
                {
                    if ( !StrEqual(titems[i], "", false) )
                    {
                        GivePlayerItem(client, titems[i]);
                    }
                }
            }
        }
    }
*/
}
//***********************************************
RemoveAllWeapons(){
//***********************************************
new maxent = GetMaxEntities(), String:weapon[64];
for (new i=MaxClients;i<maxent;i++)
	{
	if ( IsValidEdict(i) && IsValidEntity(i) && GetEntDataEnt2(i, g_WeaponParent) == -1 )
		{
		GetEdictClassname(i, weapon, sizeof(weapon));
		if (    StrContains(weapon, "weapon_") != -1                // remove weapons
				|| StrEqual(weapon, "hostage_entity", true)         // remove hostages
				|| StrContains(weapon, "item_") != -1           )   // remove bombs
			{	
				RemoveEdict(i);
			}
		}
	}
}    
